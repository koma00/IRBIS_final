//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from Pft.g4 by ANTLR 4.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace ManagedClient.Pft {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.3")]
[System.CLSCompliant(false)]
public partial class PftParser : Parser {
	public const int
		UNCONDITIONAL=1, CONDITIONAL=2, REPEATABLE=3, FIELD=4, GLOBALVAR=5, MODESWITCH=6, 
		COMMANDC=7, COMMANDX=8, LAST=9, MFN=10, IF=11, THEN=12, ELSE=13, FI=14, 
		AND=15, OR=16, NOT=17, S=18, L=19, F=20, A=21, P=22, TRIM=23, TRACE=24, 
		ERROR=25, WARNING=26, FATAL=27, DEBUG=28, IOCC=29, NOCC=30, BREAK=31, 
		PLUS=32, MINUS=33, STAR=34, SLASH=35, EQUALS=36, LPAREN=37, RPAREN=38, 
		COMMA=39, SEMICOLON=40, HASH=41, PERCENT=42, COLON=43, TILDA=44, BANG=45, 
		AMPERSAND=46, FUNCNAME=47, UNSIGNED=48, WS=49, COMMENT=50;
	public static readonly string[] tokenNames = {
		"<INVALID>", "UNCONDITIONAL", "CONDITIONAL", "REPEATABLE", "FIELD", "GLOBALVAR", 
		"MODESWITCH", "COMMANDC", "COMMANDX", "'LAST'", "MFN", "IF", "THEN", "ELSE", 
		"FI", "AND", "OR", "NOT", "S", "L", "F", "A", "P", "TRIM", "TRACE", "ERROR", 
		"WARNING", "FATAL", "DEBUG", "IOCC", "NOCC", "BREAK", "'+'", "'-'", "'*'", 
		"'/'", "'='", "'('", "')'", "','", "';'", "'$'", "'%'", "':'", "'~'", 
		"'!'", "'&'", "FUNCNAME", "UNSIGNED", "WS", "COMMENT"
	};
	public const int
		RULE_program = 0, RULE_statement = 1, RULE_groupStatement = 2, RULE_nonGrouped = 3, 
		RULE_formatItem = 4, RULE_fieldReference = 5, RULE_leftHand = 6, RULE_rightHand = 7, 
		RULE_formatExit = 8, RULE_conditionalStatement = 9, RULE_condition = 10, 
		RULE_stringTest = 11, RULE_fieldPresense = 12, RULE_sFunction = 13, RULE_trimFunction = 14, 
		RULE_iocc = 15, RULE_nocc = 16, RULE_error = 17, RULE_warning = 18, RULE_fatal = 19, 
		RULE_trace = 20, RULE_debug = 21;
	public static readonly string[] ruleNames = {
		"program", "statement", "groupStatement", "nonGrouped", "formatItem", 
		"fieldReference", "leftHand", "rightHand", "formatExit", "conditionalStatement", 
		"condition", "stringTest", "fieldPresense", "sFunction", "trimFunction", 
		"iocc", "nocc", "error", "warning", "fatal", "trace", "debug"
	};

	public override string GrammarFileName { get { return "Pft.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public PftParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class ProgramContext : ParserRuleContext {
		public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		public ITerminalNode Eof() { return GetToken(PftParser.Eof, 0); }
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterProgram(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitProgram(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_program);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 47;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << UNCONDITIONAL) | (1L << CONDITIONAL) | (1L << REPEATABLE) | (1L << FIELD) | (1L << GLOBALVAR) | (1L << MODESWITCH) | (1L << COMMANDC) | (1L << COMMANDX) | (1L << MFN) | (1L << IF) | (1L << S) | (1L << TRIM) | (1L << TRACE) | (1L << ERROR) | (1L << WARNING) | (1L << FATAL) | (1L << DEBUG) | (1L << IOCC) | (1L << NOCC) | (1L << BREAK) | (1L << SLASH) | (1L << LPAREN) | (1L << COMMA) | (1L << HASH) | (1L << PERCENT) | (1L << AMPERSAND))) != 0)) {
				{
				{
				State = 44; statement();
				}
				}
				State = 49;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 50; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public GroupStatementContext groupStatement() {
			return GetRuleContext<GroupStatementContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_statement);
		try {
			State = 54;
			switch (_input.La(1)) {
			case UNCONDITIONAL:
			case CONDITIONAL:
			case REPEATABLE:
			case FIELD:
			case GLOBALVAR:
			case MODESWITCH:
			case COMMANDC:
			case COMMANDX:
			case MFN:
			case IF:
			case S:
			case TRIM:
			case TRACE:
			case ERROR:
			case WARNING:
			case FATAL:
			case DEBUG:
			case IOCC:
			case NOCC:
			case BREAK:
			case SLASH:
			case COMMA:
			case HASH:
			case PERCENT:
			case AMPERSAND:
				EnterOuterAlt(_localctx, 1);
				{
				State = 52; nonGrouped();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 53; groupStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupStatementContext : ParserRuleContext {
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public GroupStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterGroupStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitGroupStatement(this);
		}
	}

	[RuleVersion(0)]
	public GroupStatementContext groupStatement() {
		GroupStatementContext _localctx = new GroupStatementContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_groupStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 56; Match(LPAREN);
			State = 57; nonGrouped();
			State = 58; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NonGroupedContext : ParserRuleContext {
		public NonGroupedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nonGrouped; } }
	 
		public NonGroupedContext() { }
		public virtual void CopyFrom(NonGroupedContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FormatItemPlusContext : NonGroupedContext {
		public FormatItemContext formatItem(int i) {
			return GetRuleContext<FormatItemContext>(i);
		}
		public FormatItemContext[] formatItem() {
			return GetRuleContexts<FormatItemContext>();
		}
		public FormatItemPlusContext(NonGroupedContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterFormatItemPlus(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitFormatItemPlus(this);
		}
	}

	[RuleVersion(0)]
	public NonGroupedContext nonGrouped() {
		NonGroupedContext _localctx = new NonGroupedContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_nonGrouped);
		try {
			int _alt;
			_localctx = new FormatItemPlusContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 61;
			_errHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 60; formatItem();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 63;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,2,_ctx);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FormatItemContext : ParserRuleContext {
		public FormatItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_formatItem; } }
	 
		public FormatItemContext() { }
		public virtual void CopyFrom(FormatItemContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FieldReferenceOuterContext : FormatItemContext {
		public FieldReferenceContext fieldReference() {
			return GetRuleContext<FieldReferenceContext>(0);
		}
		public FieldReferenceOuterContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterFieldReferenceOuter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitFieldReferenceOuter(this);
		}
	}
	public partial class WarningOuterContext : FormatItemContext {
		public WarningContext warning() {
			return GetRuleContext<WarningContext>(0);
		}
		public WarningOuterContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterWarningOuter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitWarningOuter(this);
		}
	}
	public partial class FatalOuterContext : FormatItemContext {
		public FatalContext fatal() {
			return GetRuleContext<FatalContext>(0);
		}
		public FatalOuterContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterFatalOuter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitFatalOuter(this);
		}
	}
	public partial class SimpleMfnContext : FormatItemContext {
		public ITerminalNode MFN() { return GetToken(PftParser.MFN, 0); }
		public SimpleMfnContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterSimpleMfn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitSimpleMfn(this);
		}
	}
	public partial class BreakContext : FormatItemContext {
		public ITerminalNode BREAK() { return GetToken(PftParser.BREAK, 0); }
		public BreakContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterBreak(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitBreak(this);
		}
	}
	public partial class ConditionalStatementOuterContext : FormatItemContext {
		public ConditionalStatementContext conditionalStatement() {
			return GetRuleContext<ConditionalStatementContext>(0);
		}
		public ConditionalStatementOuterContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterConditionalStatementOuter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitConditionalStatementOuter(this);
		}
	}
	public partial class HashNewLineContext : FormatItemContext {
		public ITerminalNode HASH() { return GetToken(PftParser.HASH, 0); }
		public HashNewLineContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterHashNewLine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitHashNewLine(this);
		}
	}
	public partial class GlobalReferenceContext : FormatItemContext {
		public ITerminalNode GLOBALVAR() { return GetToken(PftParser.GLOBALVAR, 0); }
		public GlobalReferenceContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterGlobalReference(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitGlobalReference(this);
		}
	}
	public partial class SlashNewLineContext : FormatItemContext {
		public ITerminalNode SLASH() { return GetToken(PftParser.SLASH, 0); }
		public SlashNewLineContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterSlashNewLine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitSlashNewLine(this);
		}
	}
	public partial class FormatExitOuterContext : FormatItemContext {
		public FormatExitContext formatExit() {
			return GetRuleContext<FormatExitContext>(0);
		}
		public FormatExitOuterContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterFormatExitOuter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitFormatExitOuter(this);
		}
	}
	public partial class ErrorOuterContext : FormatItemContext {
		public ErrorContext error() {
			return GetRuleContext<ErrorContext>(0);
		}
		public ErrorOuterContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterErrorOuter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitErrorOuter(this);
		}
	}
	public partial class CommandXContext : FormatItemContext {
		public ITerminalNode COMMANDX() { return GetToken(PftParser.COMMANDX, 0); }
		public CommandXContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterCommandX(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitCommandX(this);
		}
	}
	public partial class CommandCContext : FormatItemContext {
		public ITerminalNode COMMANDC() { return GetToken(PftParser.COMMANDC, 0); }
		public CommandCContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterCommandC(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitCommandC(this);
		}
	}
	public partial class TrimFunctionOuterContext : FormatItemContext {
		public TrimFunctionContext trimFunction() {
			return GetRuleContext<TrimFunctionContext>(0);
		}
		public TrimFunctionOuterContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterTrimFunctionOuter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitTrimFunctionOuter(this);
		}
	}
	public partial class SFunctionOuterContext : FormatItemContext {
		public SFunctionContext sFunction() {
			return GetRuleContext<SFunctionContext>(0);
		}
		public SFunctionOuterContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterSFunctionOuter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitSFunctionOuter(this);
		}
	}
	public partial class UnconditionalLiteralContext : FormatItemContext {
		public ITerminalNode UNCONDITIONAL() { return GetToken(PftParser.UNCONDITIONAL, 0); }
		public UnconditionalLiteralContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterUnconditionalLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitUnconditionalLiteral(this);
		}
	}
	public partial class MfnWithLengthContext : FormatItemContext {
		public ITerminalNode MFN() { return GetToken(PftParser.MFN, 0); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ITerminalNode UNSIGNED() { return GetToken(PftParser.UNSIGNED, 0); }
		public MfnWithLengthContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterMfnWithLength(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitMfnWithLength(this);
		}
	}
	public partial class TraceOuterContext : FormatItemContext {
		public TraceContext trace() {
			return GetRuleContext<TraceContext>(0);
		}
		public TraceOuterContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterTraceOuter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitTraceOuter(this);
		}
	}
	public partial class IoccOuterContext : FormatItemContext {
		public IoccContext iocc() {
			return GetRuleContext<IoccContext>(0);
		}
		public IoccOuterContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterIoccOuter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitIoccOuter(this);
		}
	}
	public partial class ModeSwitchContext : FormatItemContext {
		public ITerminalNode MODESWITCH() { return GetToken(PftParser.MODESWITCH, 0); }
		public ModeSwitchContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterModeSwitch(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitModeSwitch(this);
		}
	}
	public partial class CommaContext : FormatItemContext {
		public ITerminalNode COMMA() { return GetToken(PftParser.COMMA, 0); }
		public CommaContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterComma(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitComma(this);
		}
	}
	public partial class NoccOuterContext : FormatItemContext {
		public NoccContext nocc() {
			return GetRuleContext<NoccContext>(0);
		}
		public NoccOuterContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterNoccOuter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitNoccOuter(this);
		}
	}
	public partial class PercentNewLineContext : FormatItemContext {
		public ITerminalNode PERCENT() { return GetToken(PftParser.PERCENT, 0); }
		public PercentNewLineContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterPercentNewLine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitPercentNewLine(this);
		}
	}
	public partial class DebugOuterContext : FormatItemContext {
		public DebugContext debug() {
			return GetRuleContext<DebugContext>(0);
		}
		public DebugOuterContext(FormatItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterDebugOuter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitDebugOuter(this);
		}
	}

	[RuleVersion(0)]
	public FormatItemContext formatItem() {
		FormatItemContext _localctx = new FormatItemContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_formatItem);
		try {
			State = 92;
			switch ( Interpreter.AdaptivePredict(_input,3,_ctx) ) {
			case 1:
				_localctx = new ConditionalStatementOuterContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 65; conditionalStatement();
				}
				break;

			case 2:
				_localctx = new FieldReferenceOuterContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 66; fieldReference();
				}
				break;

			case 3:
				_localctx = new FormatExitOuterContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 67; formatExit();
				}
				break;

			case 4:
				_localctx = new ErrorOuterContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 68; error();
				}
				break;

			case 5:
				_localctx = new WarningOuterContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 69; warning();
				}
				break;

			case 6:
				_localctx = new FatalOuterContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 70; fatal();
				}
				break;

			case 7:
				_localctx = new TraceOuterContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 71; trace();
				}
				break;

			case 8:
				_localctx = new DebugOuterContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 72; debug();
				}
				break;

			case 9:
				_localctx = new SFunctionOuterContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 73; sFunction();
				}
				break;

			case 10:
				_localctx = new TrimFunctionOuterContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 74; trimFunction();
				}
				break;

			case 11:
				_localctx = new IoccOuterContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 75; iocc();
				}
				break;

			case 12:
				_localctx = new NoccOuterContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 76; nocc();
				}
				break;

			case 13:
				_localctx = new BreakContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 77; Match(BREAK);
				}
				break;

			case 14:
				_localctx = new GlobalReferenceContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 78; Match(GLOBALVAR);
				}
				break;

			case 15:
				_localctx = new UnconditionalLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 79; Match(UNCONDITIONAL);
				}
				break;

			case 16:
				_localctx = new SimpleMfnContext(_localctx);
				EnterOuterAlt(_localctx, 16);
				{
				State = 80; Match(MFN);
				}
				break;

			case 17:
				_localctx = new MfnWithLengthContext(_localctx);
				EnterOuterAlt(_localctx, 17);
				{
				State = 81; Match(MFN);
				State = 82; Match(LPAREN);
				State = 83; Match(UNSIGNED);
				State = 84; Match(RPAREN);
				}
				break;

			case 18:
				_localctx = new CommaContext(_localctx);
				EnterOuterAlt(_localctx, 18);
				{
				State = 85; Match(COMMA);
				}
				break;

			case 19:
				_localctx = new SlashNewLineContext(_localctx);
				EnterOuterAlt(_localctx, 19);
				{
				State = 86; Match(SLASH);
				}
				break;

			case 20:
				_localctx = new HashNewLineContext(_localctx);
				EnterOuterAlt(_localctx, 20);
				{
				State = 87; Match(HASH);
				}
				break;

			case 21:
				_localctx = new PercentNewLineContext(_localctx);
				EnterOuterAlt(_localctx, 21);
				{
				State = 88; Match(PERCENT);
				}
				break;

			case 22:
				_localctx = new ModeSwitchContext(_localctx);
				EnterOuterAlt(_localctx, 22);
				{
				State = 89; Match(MODESWITCH);
				}
				break;

			case 23:
				_localctx = new CommandCContext(_localctx);
				EnterOuterAlt(_localctx, 23);
				{
				State = 90; Match(COMMANDC);
				}
				break;

			case 24:
				_localctx = new CommandXContext(_localctx);
				EnterOuterAlt(_localctx, 24);
				{
				State = 91; Match(COMMANDX);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FieldReferenceContext : ParserRuleContext {
		public LeftHandContext leftHand() {
			return GetRuleContext<LeftHandContext>(0);
		}
		public RightHandContext rightHand() {
			return GetRuleContext<RightHandContext>(0);
		}
		public ITerminalNode FIELD() { return GetToken(PftParser.FIELD, 0); }
		public FieldReferenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fieldReference; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterFieldReference(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitFieldReference(this);
		}
	}

	[RuleVersion(0)]
	public FieldReferenceContext fieldReference() {
		FieldReferenceContext _localctx = new FieldReferenceContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_fieldReference);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 94; leftHand();
			State = 95; Match(FIELD);
			State = 96; rightHand();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LeftHandContext : ParserRuleContext {
		public ITerminalNode[] REPEATABLE() { return GetTokens(PftParser.REPEATABLE); }
		public ITerminalNode CONDITIONAL(int i) {
			return GetToken(PftParser.CONDITIONAL, i);
		}
		public ITerminalNode[] CONDITIONAL() { return GetTokens(PftParser.CONDITIONAL); }
		public ITerminalNode REPEATABLE(int i) {
			return GetToken(PftParser.REPEATABLE, i);
		}
		public ITerminalNode[] PLUS() { return GetTokens(PftParser.PLUS); }
		public ITerminalNode PLUS(int i) {
			return GetToken(PftParser.PLUS, i);
		}
		public LeftHandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_leftHand; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterLeftHand(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitLeftHand(this);
		}
	}

	[RuleVersion(0)]
	public LeftHandContext leftHand() {
		LeftHandContext _localctx = new LeftHandContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_leftHand);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 105;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==CONDITIONAL || _la==REPEATABLE) {
				{
				State = 103;
				switch (_input.La(1)) {
				case REPEATABLE:
					{
					State = 98; Match(REPEATABLE);
					State = 100;
					_la = _input.La(1);
					if (_la==PLUS) {
						{
						State = 99; Match(PLUS);
						}
					}

					}
					break;
				case CONDITIONAL:
					{
					State = 102; Match(CONDITIONAL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 107;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RightHandContext : ParserRuleContext {
		public ITerminalNode[] REPEATABLE() { return GetTokens(PftParser.REPEATABLE); }
		public ITerminalNode CONDITIONAL(int i) {
			return GetToken(PftParser.CONDITIONAL, i);
		}
		public ITerminalNode[] CONDITIONAL() { return GetTokens(PftParser.CONDITIONAL); }
		public ITerminalNode REPEATABLE(int i) {
			return GetToken(PftParser.REPEATABLE, i);
		}
		public ITerminalNode[] PLUS() { return GetTokens(PftParser.PLUS); }
		public ITerminalNode PLUS(int i) {
			return GetToken(PftParser.PLUS, i);
		}
		public RightHandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rightHand; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterRightHand(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitRightHand(this);
		}
	}

	[RuleVersion(0)]
	public RightHandContext rightHand() {
		RightHandContext _localctx = new RightHandContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_rightHand);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 115;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,9,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					State = 113;
					switch (_input.La(1)) {
					case REPEATABLE:
					case PLUS:
						{
						State = 109;
						_la = _input.La(1);
						if (_la==PLUS) {
							{
							State = 108; Match(PLUS);
							}
						}

						State = 111; Match(REPEATABLE);
						}
						break;
					case CONDITIONAL:
						{
						State = 112; Match(CONDITIONAL);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 117;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,9,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FormatExitContext : ParserRuleContext {
		public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public ITerminalNode AMPERSAND() { return GetToken(PftParser.AMPERSAND, 0); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ITerminalNode FUNCNAME() { return GetToken(PftParser.FUNCNAME, 0); }
		public FormatExitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_formatExit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterFormatExit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitFormatExit(this);
		}
	}

	[RuleVersion(0)]
	public FormatExitContext formatExit() {
		FormatExitContext _localctx = new FormatExitContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_formatExit);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 118; Match(AMPERSAND);
			State = 119; Match(FUNCNAME);
			State = 120; Match(LPAREN);
			State = 121; statement();
			State = 122; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalStatementContext : ParserRuleContext {
		public StatementContext thenBranch;
		public StatementContext elseBranch;
		public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		public ITerminalNode THEN() { return GetToken(PftParser.THEN, 0); }
		public ITerminalNode IF() { return GetToken(PftParser.IF, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode FI() { return GetToken(PftParser.FI, 0); }
		public ITerminalNode ELSE() { return GetToken(PftParser.ELSE, 0); }
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public ConditionalStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterConditionalStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitConditionalStatement(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalStatementContext conditionalStatement() {
		ConditionalStatementContext _localctx = new ConditionalStatementContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_conditionalStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124; Match(IF);
			State = 125; condition(0);
			State = 126; Match(THEN);
			State = 127; _localctx.thenBranch = statement();
			State = 130;
			_la = _input.La(1);
			if (_la==ELSE) {
				{
				State = 128; Match(ELSE);
				State = 129; _localctx.elseBranch = statement();
				}
			}

			State = 132; Match(FI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionContext : ParserRuleContext {
		public ConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_condition; } }
	 
		public ConditionContext() { }
		public virtual void CopyFrom(ConditionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ConditionParenContext : ConditionContext {
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ConditionParenContext(ConditionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterConditionParen(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitConditionParen(this);
		}
	}
	public partial class ConditionStringContext : ConditionContext {
		public StringTestContext stringTest() {
			return GetRuleContext<StringTestContext>(0);
		}
		public ConditionStringContext(ConditionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterConditionString(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitConditionString(this);
		}
	}
	public partial class ConditionFieldContext : ConditionContext {
		public FieldPresenseContext fieldPresense() {
			return GetRuleContext<FieldPresenseContext>(0);
		}
		public ConditionFieldContext(ConditionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterConditionField(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitConditionField(this);
		}
	}
	public partial class ConditionNotContext : ConditionContext {
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(PftParser.NOT, 0); }
		public ConditionNotContext(ConditionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterConditionNot(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitConditionNot(this);
		}
	}
	public partial class ConditionAndOrContext : ConditionContext {
		public IToken op;
		public ConditionContext[] condition() {
			return GetRuleContexts<ConditionContext>();
		}
		public ITerminalNode AND() { return GetToken(PftParser.AND, 0); }
		public ConditionContext condition(int i) {
			return GetRuleContext<ConditionContext>(i);
		}
		public ITerminalNode OR() { return GetToken(PftParser.OR, 0); }
		public ConditionAndOrContext(ConditionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterConditionAndOr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitConditionAndOr(this);
		}
	}

	[RuleVersion(0)]
	public ConditionContext condition() {
		return condition(0);
	}

	private ConditionContext condition(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ConditionContext _localctx = new ConditionContext(_ctx, _parentState);
		ConditionContext _prevctx = _localctx;
		int _startState = 20;
		EnterRecursionRule(_localctx, 20, RULE_condition, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 143;
			switch (_input.La(1)) {
			case NOT:
				{
				_localctx = new ConditionNotContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 135; Match(NOT);
				State = 136; condition(4);
				}
				break;
			case LPAREN:
				{
				_localctx = new ConditionParenContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 137; Match(LPAREN);
				State = 138; condition(0);
				State = 139; Match(RPAREN);
				}
				break;
			case UNCONDITIONAL:
			case CONDITIONAL:
			case REPEATABLE:
			case FIELD:
				{
				_localctx = new ConditionStringContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 141; stringTest();
				}
				break;
			case A:
			case P:
				{
				_localctx = new ConditionFieldContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 142; fieldPresense();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 150;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,12,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ConditionAndOrContext(new ConditionContext(_parentctx, _parentState));
					PushNewRecursionContext(_localctx, _startState, RULE_condition);
					State = 145;
					if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
					State = 146;
					((ConditionAndOrContext)_localctx).op = _input.Lt(1);
					_la = _input.La(1);
					if ( !(_la==AND || _la==OR) ) {
						((ConditionAndOrContext)_localctx).op = _errHandler.RecoverInline(this);
					}
					Consume();
					State = 147; condition(6);
					}
					} 
				}
				State = 152;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,12,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class StringTestContext : ParserRuleContext {
		public StringTestContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringTest; } }
	 
		public StringTestContext() { }
		public virtual void CopyFrom(StringTestContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class StringTestReverseContext : StringTestContext {
		public IToken left;
		public IToken op;
		public FieldReferenceContext right;
		public ITerminalNode UNCONDITIONAL() { return GetToken(PftParser.UNCONDITIONAL, 0); }
		public ITerminalNode EQUALS() { return GetToken(PftParser.EQUALS, 0); }
		public ITerminalNode COLON() { return GetToken(PftParser.COLON, 0); }
		public FieldReferenceContext fieldReference() {
			return GetRuleContext<FieldReferenceContext>(0);
		}
		public StringTestReverseContext(StringTestContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterStringTestReverse(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitStringTestReverse(this);
		}
	}
	public partial class StringTestDirectContext : StringTestContext {
		public FieldReferenceContext left;
		public IToken op;
		public IToken right;
		public ITerminalNode UNCONDITIONAL() { return GetToken(PftParser.UNCONDITIONAL, 0); }
		public ITerminalNode EQUALS() { return GetToken(PftParser.EQUALS, 0); }
		public ITerminalNode COLON() { return GetToken(PftParser.COLON, 0); }
		public FieldReferenceContext fieldReference() {
			return GetRuleContext<FieldReferenceContext>(0);
		}
		public StringTestDirectContext(StringTestContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterStringTestDirect(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitStringTestDirect(this);
		}
	}

	[RuleVersion(0)]
	public StringTestContext stringTest() {
		StringTestContext _localctx = new StringTestContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_stringTest);
		int _la;
		try {
			State = 160;
			switch (_input.La(1)) {
			case CONDITIONAL:
			case REPEATABLE:
			case FIELD:
				_localctx = new StringTestDirectContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 153; ((StringTestDirectContext)_localctx).left = fieldReference();
				State = 154;
				((StringTestDirectContext)_localctx).op = _input.Lt(1);
				_la = _input.La(1);
				if ( !(_la==EQUALS || _la==COLON) ) {
					((StringTestDirectContext)_localctx).op = _errHandler.RecoverInline(this);
				}
				Consume();
				State = 155; ((StringTestDirectContext)_localctx).right = Match(UNCONDITIONAL);
				}
				break;
			case UNCONDITIONAL:
				_localctx = new StringTestReverseContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 157; ((StringTestReverseContext)_localctx).left = Match(UNCONDITIONAL);
				State = 158;
				((StringTestReverseContext)_localctx).op = _input.Lt(1);
				_la = _input.La(1);
				if ( !(_la==EQUALS || _la==COLON) ) {
					((StringTestReverseContext)_localctx).op = _errHandler.RecoverInline(this);
				}
				Consume();
				State = 159; ((StringTestReverseContext)_localctx).right = fieldReference();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FieldPresenseContext : ParserRuleContext {
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode A() { return GetToken(PftParser.A, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ITerminalNode P() { return GetToken(PftParser.P, 0); }
		public FieldReferenceContext fieldReference() {
			return GetRuleContext<FieldReferenceContext>(0);
		}
		public FieldPresenseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fieldPresense; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterFieldPresense(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitFieldPresense(this);
		}
	}

	[RuleVersion(0)]
	public FieldPresenseContext fieldPresense() {
		FieldPresenseContext _localctx = new FieldPresenseContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_fieldPresense);
		try {
			State = 172;
			switch (_input.La(1)) {
			case P:
				EnterOuterAlt(_localctx, 1);
				{
				State = 162; Match(P);
				State = 163; Match(LPAREN);
				State = 164; fieldReference();
				State = 165; Match(RPAREN);
				}
				break;
			case A:
				EnterOuterAlt(_localctx, 2);
				{
				State = 167; Match(A);
				State = 168; Match(LPAREN);
				State = 169; fieldReference();
				State = 170; Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SFunctionContext : ParserRuleContext {
		public ITerminalNode S() { return GetToken(PftParser.S, 0); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public SFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterSFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitSFunction(this);
		}
	}

	[RuleVersion(0)]
	public SFunctionContext sFunction() {
		SFunctionContext _localctx = new SFunctionContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_sFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 174; Match(S);
			State = 175; Match(LPAREN);
			State = 176; nonGrouped();
			State = 177; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TrimFunctionContext : ParserRuleContext {
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode TRIM() { return GetToken(PftParser.TRIM, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public TrimFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trimFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterTrimFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitTrimFunction(this);
		}
	}

	[RuleVersion(0)]
	public TrimFunctionContext trimFunction() {
		TrimFunctionContext _localctx = new TrimFunctionContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_trimFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 179; Match(TRIM);
			State = 180; Match(LPAREN);
			State = 181; nonGrouped();
			State = 182; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IoccContext : ParserRuleContext {
		public ITerminalNode IOCC() { return GetToken(PftParser.IOCC, 0); }
		public IoccContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_iocc; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterIocc(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitIocc(this);
		}
	}

	[RuleVersion(0)]
	public IoccContext iocc() {
		IoccContext _localctx = new IoccContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_iocc);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 184; Match(IOCC);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NoccContext : ParserRuleContext {
		public ITerminalNode NOCC() { return GetToken(PftParser.NOCC, 0); }
		public NoccContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nocc; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterNocc(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitNocc(this);
		}
	}

	[RuleVersion(0)]
	public NoccContext nocc() {
		NoccContext _localctx = new NoccContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_nocc);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 186; Match(NOCC);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ErrorContext : ParserRuleContext {
		public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode ERROR() { return GetToken(PftParser.ERROR, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ErrorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_error; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterError(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitError(this);
		}
	}

	[RuleVersion(0)]
	public ErrorContext error() {
		ErrorContext _localctx = new ErrorContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_error);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 188; Match(ERROR);
			State = 189; Match(LPAREN);
			State = 190; statement();
			State = 191; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WarningContext : ParserRuleContext {
		public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode WARNING() { return GetToken(PftParser.WARNING, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public WarningContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_warning; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterWarning(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitWarning(this);
		}
	}

	[RuleVersion(0)]
	public WarningContext warning() {
		WarningContext _localctx = new WarningContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_warning);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 193; Match(WARNING);
			State = 194; Match(LPAREN);
			State = 195; statement();
			State = 196; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FatalContext : ParserRuleContext {
		public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode FATAL() { return GetToken(PftParser.FATAL, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public FatalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fatal; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterFatal(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitFatal(this);
		}
	}

	[RuleVersion(0)]
	public FatalContext fatal() {
		FatalContext _localctx = new FatalContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_fatal);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 198; Match(FATAL);
			State = 199; Match(LPAREN);
			State = 200; statement();
			State = 201; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TraceContext : ParserRuleContext {
		public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public ITerminalNode TRACE() { return GetToken(PftParser.TRACE, 0); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public TraceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trace; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterTrace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitTrace(this);
		}
	}

	[RuleVersion(0)]
	public TraceContext trace() {
		TraceContext _localctx = new TraceContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_trace);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 203; Match(TRACE);
			State = 204; Match(LPAREN);
			State = 205; statement();
			State = 206; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DebugContext : ParserRuleContext {
		public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public ITerminalNode DEBUG() { return GetToken(PftParser.DEBUG, 0); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public DebugContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_debug; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterDebug(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitDebug(this);
		}
	}

	[RuleVersion(0)]
	public DebugContext debug() {
		DebugContext _localctx = new DebugContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_debug);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 208; Match(DEBUG);
			State = 209; Match(LPAREN);
			State = 210; statement();
			State = 211; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 10: return condition_sempred((ConditionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool condition_sempred(ConditionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 5);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\x34\xD8\x4\x2\t"+
		"\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t"+
		"\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x3\x2\a\x2\x30\n\x2\f\x2\xE\x2\x33\v\x2\x3"+
		"\x2\x3\x2\x3\x3\x3\x3\x5\x3\x39\n\x3\x3\x4\x3\x4\x3\x4\x3\x4\x3\x5\x6"+
		"\x5@\n\x5\r\x5\xE\x5\x41\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3"+
		"\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6"+
		"\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x5\x6_\n\x6\x3\a\x3\a"+
		"\x3\a\x3\a\x3\b\x3\b\x5\bg\n\b\x3\b\a\bj\n\b\f\b\xE\bm\v\b\x3\t\x5\tp"+
		"\n\t\x3\t\x3\t\a\tt\n\t\f\t\xE\tw\v\t\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3"+
		"\v\x3\v\x3\v\x3\v\x3\v\x3\v\x5\v\x85\n\v\x3\v\x3\v\x3\f\x3\f\x3\f\x3\f"+
		"\x3\f\x3\f\x3\f\x3\f\x3\f\x5\f\x92\n\f\x3\f\x3\f\x3\f\a\f\x97\n\f\f\f"+
		"\xE\f\x9A\v\f\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x5\r\xA3\n\r\x3\xE\x3"+
		"\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x5\xE\xAF\n\xE\x3"+
		"\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x11"+
		"\x3\x11\x3\x12\x3\x12\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x14\x3\x14"+
		"\x3\x14\x3\x14\x3\x14\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x16\x3\x16"+
		"\x3\x16\x3\x16\x3\x16\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x2\x2"+
		"\x3\x16\x18\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12\x2\x14\x2"+
		"\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2&\x2(\x2*\x2,\x2\x2\x4"+
		"\x3\x2\x11\x12\x4\x2&&--\xE8\x2\x31\x3\x2\x2\x2\x4\x38\x3\x2\x2\x2\x6"+
		":\x3\x2\x2\x2\b?\x3\x2\x2\x2\n^\x3\x2\x2\x2\f`\x3\x2\x2\x2\xEk\x3\x2\x2"+
		"\x2\x10u\x3\x2\x2\x2\x12x\x3\x2\x2\x2\x14~\x3\x2\x2\x2\x16\x91\x3\x2\x2"+
		"\x2\x18\xA2\x3\x2\x2\x2\x1A\xAE\x3\x2\x2\x2\x1C\xB0\x3\x2\x2\x2\x1E\xB5"+
		"\x3\x2\x2\x2 \xBA\x3\x2\x2\x2\"\xBC\x3\x2\x2\x2$\xBE\x3\x2\x2\x2&\xC3"+
		"\x3\x2\x2\x2(\xC8\x3\x2\x2\x2*\xCD\x3\x2\x2\x2,\xD2\x3\x2\x2\x2.\x30\x5"+
		"\x4\x3\x2/.\x3\x2\x2\x2\x30\x33\x3\x2\x2\x2\x31/\x3\x2\x2\x2\x31\x32\x3"+
		"\x2\x2\x2\x32\x34\x3\x2\x2\x2\x33\x31\x3\x2\x2\x2\x34\x35\a\x2\x2\x3\x35"+
		"\x3\x3\x2\x2\x2\x36\x39\x5\b\x5\x2\x37\x39\x5\x6\x4\x2\x38\x36\x3\x2\x2"+
		"\x2\x38\x37\x3\x2\x2\x2\x39\x5\x3\x2\x2\x2:;\a\'\x2\x2;<\x5\b\x5\x2<="+
		"\a(\x2\x2=\a\x3\x2\x2\x2>@\x5\n\x6\x2?>\x3\x2\x2\x2@\x41\x3\x2\x2\x2\x41"+
		"?\x3\x2\x2\x2\x41\x42\x3\x2\x2\x2\x42\t\x3\x2\x2\x2\x43_\x5\x14\v\x2\x44"+
		"_\x5\f\a\x2\x45_\x5\x12\n\x2\x46_\x5$\x13\x2G_\x5&\x14\x2H_\x5(\x15\x2"+
		"I_\x5*\x16\x2J_\x5,\x17\x2K_\x5\x1C\xF\x2L_\x5\x1E\x10\x2M_\x5 \x11\x2"+
		"N_\x5\"\x12\x2O_\a!\x2\x2P_\a\a\x2\x2Q_\a\x3\x2\x2R_\a\f\x2\x2ST\a\f\x2"+
		"\x2TU\a\'\x2\x2UV\a\x32\x2\x2V_\a(\x2\x2W_\a)\x2\x2X_\a%\x2\x2Y_\a+\x2"+
		"\x2Z_\a,\x2\x2[_\a\b\x2\x2\\_\a\t\x2\x2]_\a\n\x2\x2^\x43\x3\x2\x2\x2^"+
		"\x44\x3\x2\x2\x2^\x45\x3\x2\x2\x2^\x46\x3\x2\x2\x2^G\x3\x2\x2\x2^H\x3"+
		"\x2\x2\x2^I\x3\x2\x2\x2^J\x3\x2\x2\x2^K\x3\x2\x2\x2^L\x3\x2\x2\x2^M\x3"+
		"\x2\x2\x2^N\x3\x2\x2\x2^O\x3\x2\x2\x2^P\x3\x2\x2\x2^Q\x3\x2\x2\x2^R\x3"+
		"\x2\x2\x2^S\x3\x2\x2\x2^W\x3\x2\x2\x2^X\x3\x2\x2\x2^Y\x3\x2\x2\x2^Z\x3"+
		"\x2\x2\x2^[\x3\x2\x2\x2^\\\x3\x2\x2\x2^]\x3\x2\x2\x2_\v\x3\x2\x2\x2`\x61"+
		"\x5\xE\b\x2\x61\x62\a\x6\x2\x2\x62\x63\x5\x10\t\x2\x63\r\x3\x2\x2\x2\x64"+
		"\x66\a\x5\x2\x2\x65g\a\"\x2\x2\x66\x65\x3\x2\x2\x2\x66g\x3\x2\x2\x2gj"+
		"\x3\x2\x2\x2hj\a\x4\x2\x2i\x64\x3\x2\x2\x2ih\x3\x2\x2\x2jm\x3\x2\x2\x2"+
		"ki\x3\x2\x2\x2kl\x3\x2\x2\x2l\xF\x3\x2\x2\x2mk\x3\x2\x2\x2np\a\"\x2\x2"+
		"on\x3\x2\x2\x2op\x3\x2\x2\x2pq\x3\x2\x2\x2qt\a\x5\x2\x2rt\a\x4\x2\x2s"+
		"o\x3\x2\x2\x2sr\x3\x2\x2\x2tw\x3\x2\x2\x2us\x3\x2\x2\x2uv\x3\x2\x2\x2"+
		"v\x11\x3\x2\x2\x2wu\x3\x2\x2\x2xy\a\x30\x2\x2yz\a\x31\x2\x2z{\a\'\x2\x2"+
		"{|\x5\x4\x3\x2|}\a(\x2\x2}\x13\x3\x2\x2\x2~\x7F\a\r\x2\x2\x7F\x80\x5\x16"+
		"\f\x2\x80\x81\a\xE\x2\x2\x81\x84\x5\x4\x3\x2\x82\x83\a\xF\x2\x2\x83\x85"+
		"\x5\x4\x3\x2\x84\x82\x3\x2\x2\x2\x84\x85\x3\x2\x2\x2\x85\x86\x3\x2\x2"+
		"\x2\x86\x87\a\x10\x2\x2\x87\x15\x3\x2\x2\x2\x88\x89\b\f\x1\x2\x89\x8A"+
		"\a\x13\x2\x2\x8A\x92\x5\x16\f\x6\x8B\x8C\a\'\x2\x2\x8C\x8D\x5\x16\f\x2"+
		"\x8D\x8E\a(\x2\x2\x8E\x92\x3\x2\x2\x2\x8F\x92\x5\x18\r\x2\x90\x92\x5\x1A"+
		"\xE\x2\x91\x88\x3\x2\x2\x2\x91\x8B\x3\x2\x2\x2\x91\x8F\x3\x2\x2\x2\x91"+
		"\x90\x3\x2\x2\x2\x92\x98\x3\x2\x2\x2\x93\x94\f\a\x2\x2\x94\x95\t\x2\x2"+
		"\x2\x95\x97\x5\x16\f\b\x96\x93\x3\x2\x2\x2\x97\x9A\x3\x2\x2\x2\x98\x96"+
		"\x3\x2\x2\x2\x98\x99\x3\x2\x2\x2\x99\x17\x3\x2\x2\x2\x9A\x98\x3\x2\x2"+
		"\x2\x9B\x9C\x5\f\a\x2\x9C\x9D\t\x3\x2\x2\x9D\x9E\a\x3\x2\x2\x9E\xA3\x3"+
		"\x2\x2\x2\x9F\xA0\a\x3\x2\x2\xA0\xA1\t\x3\x2\x2\xA1\xA3\x5\f\a\x2\xA2"+
		"\x9B\x3\x2\x2\x2\xA2\x9F\x3\x2\x2\x2\xA3\x19\x3\x2\x2\x2\xA4\xA5\a\x18"+
		"\x2\x2\xA5\xA6\a\'\x2\x2\xA6\xA7\x5\f\a\x2\xA7\xA8\a(\x2\x2\xA8\xAF\x3"+
		"\x2\x2\x2\xA9\xAA\a\x17\x2\x2\xAA\xAB\a\'\x2\x2\xAB\xAC\x5\f\a\x2\xAC"+
		"\xAD\a(\x2\x2\xAD\xAF\x3\x2\x2\x2\xAE\xA4\x3\x2\x2\x2\xAE\xA9\x3\x2\x2"+
		"\x2\xAF\x1B\x3\x2\x2\x2\xB0\xB1\a\x14\x2\x2\xB1\xB2\a\'\x2\x2\xB2\xB3"+
		"\x5\b\x5\x2\xB3\xB4\a(\x2\x2\xB4\x1D\x3\x2\x2\x2\xB5\xB6\a\x19\x2\x2\xB6"+
		"\xB7\a\'\x2\x2\xB7\xB8\x5\b\x5\x2\xB8\xB9\a(\x2\x2\xB9\x1F\x3\x2\x2\x2"+
		"\xBA\xBB\a\x1F\x2\x2\xBB!\x3\x2\x2\x2\xBC\xBD\a \x2\x2\xBD#\x3\x2\x2\x2"+
		"\xBE\xBF\a\x1B\x2\x2\xBF\xC0\a\'\x2\x2\xC0\xC1\x5\x4\x3\x2\xC1\xC2\a("+
		"\x2\x2\xC2%\x3\x2\x2\x2\xC3\xC4\a\x1C\x2\x2\xC4\xC5\a\'\x2\x2\xC5\xC6"+
		"\x5\x4\x3\x2\xC6\xC7\a(\x2\x2\xC7\'\x3\x2\x2\x2\xC8\xC9\a\x1D\x2\x2\xC9"+
		"\xCA\a\'\x2\x2\xCA\xCB\x5\x4\x3\x2\xCB\xCC\a(\x2\x2\xCC)\x3\x2\x2\x2\xCD"+
		"\xCE\a\x1A\x2\x2\xCE\xCF\a\'\x2\x2\xCF\xD0\x5\x4\x3\x2\xD0\xD1\a(\x2\x2"+
		"\xD1+\x3\x2\x2\x2\xD2\xD3\a\x1E\x2\x2\xD3\xD4\a\'\x2\x2\xD4\xD5\x5\x4"+
		"\x3\x2\xD5\xD6\a(\x2\x2\xD6-\x3\x2\x2\x2\x11\x31\x38\x41^\x66ikosu\x84"+
		"\x91\x98\xA2\xAE";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace ManagedClient.Pft
